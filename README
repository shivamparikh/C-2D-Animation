Group Member: Shivam ParikhPurpose of the animation: The animation I developed is a miniature model of scenes from Star Wars. It starts with a Sun near the middle of the screen at a user specified point, a blue planet revolving around the Sun, a moon revolving around the planet, and a moon revolving around the first moon. There is also a second planet revolving around the sun, but this planet is a magenta color and it has a few rings around it, making it seem like a gas giant planet in our solar system. There are randomly generated stars that cover the background as well. In the top right corner, there is a Death Star shape, which later fires a green laser towards Alderan, the planet in the top left of the screen. The green laser destroys the planet Alderan. While all this is happening, a spaceship squadron left the magenta planet at the beginning of the animation, and travels in an elliptical orbit, reaching the same x-position as the Death Star. Then, the squadron travels in a straight line to reach the Death Star. Once they reach, two spaceships exit the Death Star, while one stays behind. This symbolizes Luke Skywalker staying behind in the Death Star in Episode 6 to finish up some family business. The moon of the planet is continuously shooting shots at the Death Star every time it approaches the top of the orbit. ¾ of the way through the animation, the third space ship leaves the Death Star and it begins to shrink into its destruction. It flashes red and grey while shrinking until it disappears. The planets and moons remain in motion throughout and stop shooting at the Death Star because it no longer exists. The animation ends after one minute. Algorithms used: To draw the circles, I used the distance formula to find the pixels surrounding the center point that should be colored, and then went on to color them. In the beginning, I was scanning through the entirety of the frame to find the pixels to shade. However, I found that it would be more efficient to define the possible area first, and then scan that area only. To do this, I calculated the minimum and maximum X values, and the maximum Y value. The minimum Y could not be used because a segmentation fault was returned when defining the array location with a variable, so I ended up using 0. I called this the ‘Predictive Pixel Method’. Even so, my program went from generating 1 frame every 3.3 seconds, to 1 frame every 0.136 seconds, or the equivalent of 7.3 frames per second. To calculate these times, I used <ctime>. With it, I measured the time to draw the stars, the time to draw the whole frame, and the time to draw all the frames. The massive change in efficiency in generating the frames showed me the power of using algorithms to make the production of graphics far more efficient. The minute long animation that once took nearly 2 hours now could be finished in just 4 minutes. With improved efficiency, this program could even be used to render animations in real-time. I implemented this Predictive Pixel Method to all the shapes I drew, including the rectangles and spaceships. The rectangle class uses a simplified distance formula to draw the pixels in the specified length and width. It is essentially what the Predictive Pixel Method uses to define the possible locations of the shape’s pixels. To draw the spaceship in the TShip class, I implemented one circle as the body and two rectangles for the wings. To model the circular and elliptical paths, I used the parametric equations of a circle and ellipse with the independent variable as the angle. (Circle: x=r*cosθ, y=r*sinθ) (Ellipse: x=A*cosθ, y=B*sinθ). To determine the time to shoot the lasers, I divided the 360 degrees by the angular speed to determine at which frequency to fire the laser from the moon to the Death Star. Majority of the locations except the Sun are all relative to the given parameters set by the user. The user sets the Sun’s location and the frame size. For example, the Death Star is a certain distance away from the top right of the screen. The planets are a variable distance away from the Sun, and so on. I used a random number generator to determine the position and the intensity of the stars. The stars encountered a segmentation error when generating a large amount with the Predictive Pixel Method due to memory allocation, so I did not limit the y search and only limited the x direction search. Though it was not as fast as the full PPM, it was more efficient than the full frame search. Run Time Instructions: To run the animation, the user can open the ‘config_data_final.txt’ file and set the parameters they would like. These parameters are defined in the name next to them. Some guidelines: If the revolve speed of an object is negative, it travels clockwise. If the speed is positive, it will travel counter-clockwise. In most cases, the speed is in some way directly proportional to the number of pixels so choose it with respect to the size of the frame you chose. While the program is most likely already compiled, the user can choose to compile it if it has not been run. However, editing the config_data_final.txt file will not require the user to recompile. To compile: g++ -o animate animate.cpp Circle.cpp Color.cpp Rect.cpp TShip.cppTo run: ./animate config_data_final.txtTo convert the files that are output:mogrify -format jpeg *.bmpTo delete all the .bmp files that take up lots of storage:rm *.bmpTo convert the .jpeg files into a .mp4 file:-The underlined parts are variable. The first signifies the number of seconds for 100 frames. The second is the resolution of the final .mp4 video file. The third is the file name you would like it to output. convert -delay 4 -loop 0 *.jpeg -scale 1920x1080 starWarsILove.mp4